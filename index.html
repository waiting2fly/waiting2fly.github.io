<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Github博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="tech">
<meta name="keywords" content="blog">
<meta property="og:type" content="website">
<meta property="og:title" content="Github博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Github博客">
<meta property="og:description" content="tech">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Github博客">
<meta name="twitter:description" content="tech">
  
    <link rel="alternate" href="/atom.xml" title="Github博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Github博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">intersting</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Java核心技术-继承" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/09/Java核心技术-继承/" class="article-date">
  <time datetime="2018-09-09T15:59:25.000Z" itemprop="datePublished">2018-09-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/09/Java核心技术-继承/">Java核心技术-继承</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1 类、超类和子类<br>“is-a”关系是继承的一个明显特征。</p>
<p>1.1 定义子类<br>关键字extends表示继承</p>
<p>关键字extends表明正在构造的新类派生于一个已存在的类，已存在的类称为超类，新类称为子类，子类比超类拥有的功能更加丰富。</p>
<p>在通过扩展超类定义子类的时候，仅需要指出子类与超类的不同之处。因此在设计类的时候，应该将通用的方法放在超类中，而将具有特殊用途的方法放在子类中。</p>
<p>1.2 覆盖方法<br>子类继承来的私有域只有通过超类的方法才能访问。（super关键字）</p>
<p>super与this的区别:</p>
<p>super关键字不是一个对象的引用，不能将super赋给另一个对象变量，它只是一个指示编译器调用超类方法的特殊关键字。</p>
<p>在子类中可以增加域、增加方法或覆盖超类的方法，但不能删除继承的任何域和方法。</p>
<p>1.3 子类构造器<br>由于子类的构造器不能访问超类的私有域，所以必须利用超类的构造器对这部分私有域进行初始化，我们可以通过super实现对超类构造器的调用。</p>
<p>使用super调用构造器的语句必须是子类构造器的第一条语句。</p>
<p>关键字this的两个用途：1.引用隐式参数；2.调用该类的其他的构造器。</p>
<p>关键字super的两个用途：1.调用超类的方法；2.调用超类的构造器</p>
<p>相同点：调用构造器的语句只能作为另一个构造器的第一条语句出现。</p>
<p>。在运行时能够自动地选择调用哪个方法的现象称为动态绑定。</p>
<p>1.4 继承层次<br>由一个公共超类派生出来的所有类的集合被称为继承层次，从某个特定的类到其祖先的路径被称为该类的继承链。</p>
<p>1.5 多态<br>一个对象变量可以指示多种实际类型的现象被称为多态</p>
<p>用来判断是否应该设计为继承关系的简单规则：”is-a“规则，它表明子类的每个对象也是超类的对象。</p>
<p>对象变量是多态的。</p>
<p>1.6 理解方法调用<br>当调用类C的一个对象的f方法时：</p>
<p>1.提取对象实际类型的方法表：编译器会一一列举C类的所有名为f的方法和其超类中访问属性为public且名为f的方法</p>
<p>2.重载解析：找到参数类型完全匹配的方法。（允许子类将覆盖方法的返回类型定义为原返回类型的子类型）。</p>
<p>3.静态绑定：如果是private方法、static方法、final方法或者构造器，那么编译器将可以准确地知道应该调用哪个方法（否则执行4）</p>
<p>4.动态绑定：虚拟机调用与引用对象的实际类型最合适的类方法。</p>
<p>动态绑定的重要特性：无需对现存代码进行修改，就可以对程序进行扩展。</p>
<p>在覆盖一个方法的时候，子类方法不能低于超类方法的可见性（超类方法为public，子类方法不能遗漏public修饰符）。</p>
<p>1.7 阻止继承：final类和方法<br>不允许扩展的类被称为final类，final方法不允许子类覆盖（final类中的所有方法自动称为final方法，不包括域）</p>
<p>例如：String类是final类；Calendar类中的getTime和setTime方法声明为final。</p>
<p>内联：如果一个方法很短、经常被调用并且没有真正地被覆盖，即时编译器就能够对它进行优化处理（e.getName()-&gt;e.name）</p>
<p>1.8 强制类型转换<br>将一个子类的引用赋给一个超类变量，编译器是允许的。但将一个超类的引用赋给一个子类变量，必须进行类型转换。</p>
<p>只有在需要使用子类中特有的方法时才需要进行类型转换。</p>
<p>一个良好的设计习惯：在进行类型转换之前，先查看一下是否能够成功地转换。（使用instanceof操作符）</p>
<p>总结：</p>
<p>*只能在继承层次内进行类型转换。</p>
<p>*在将超类转换成子类之前，应该使用instanceof进行检查。</p>
<p>1.9 抽象类<br>被abstract关键字修饰的类称为抽象类，可以不包含抽象方法。</p>
<p>包含一个或多个抽象方法的类本身必须被声明为抽象的（abstract），除了抽象方法外，抽象类还可以包含具体数据和方法。</p>
<p>1.10 受保护访问<br>如果希望超类中的某些方法允许被子类访问，或允许子类的方法访问超类的某个域，可以将这些方法或域声明为protected。</p>
<p>Java用于控制可见性的4个访问修饰符：</p>
<p>1.仅对本类可见——private</p>
<p>2.对所有类可见——public</p>
<p>3.对本包和所有子类可见——protected</p>
<p>4.对本包可见——默认，不需要修饰符</p>
<p>2 Object：所有类的超类<br>Object类是Java中所有类的始祖，在Java中每个类都是由它扩展而来。</p>
<p>在Java中只有基本类型不是对象。</p>
<p>2.1 equals方法<br>Object类中的equals方法用于判断一个对象是否等于另一个对象（通过是否具有相同引用的方式）</p>
<p>一般情况下需要覆盖这种判断方式，通过两个对象状态的相等性来判断。</p>
<p>为了防备null情况，需要使用Object.equals（a，b）方法。如果两个参数都为null返回true，如果其中一个为null返回false，如果两个参数都不为null，调用a.equals(b).</p>
<p>2.2 相等测试与继承</p>
<p>对于数组类型的域，可以使用静态的Arrays.equals方法检测相应的数组元素是否相等。</p>
<p>2.3 hashCode方法<br>散列码是由对象导出的一个整型值。。</p>
<p>由于hashCode方法定义在Object类中，因此每个对象都有一个默认的散列码。其值为对象的存储地址。</p>
<p>如果重新定义equals方法，就必须重新定义hashCode方法。</p>
<p>使用Object.hash方法计算各个域值hash。</p>
<p>Object.hash(name,salary,hireDay)</p>
<p>equals中比较使用的域值应该和hashCode中相同。</p>
<p>2.4 toString方法<br>Object类定义了toString方法，用来打印输出对象所属的类名和散列码。</p>
<p>绝大多数的toString方法都遵循这样的格式：类的名字（getClass().getName()），随后是一对方括号阔气来的域值.</p>
<p>数组继承了object类的toString方法，修正方式是调用静态的Arrays.toString或者Arrays.deepToString方法。</p>
<p>强烈建议为自定义的没一个类增加一个toString方法</p>
<p>3 泛型数组列表<br>ArrayList是一个采用类型参数的泛型类。</p>
<p>使用”菱形“语法可以省去右边的类型参数。</p>
<p>一旦能够确认数组列表的大小不再变化，可以调用trimToSize方法。垃圾回收器将回收多余的存储空间。</p>
<p>3.1 访问数组列表元素<br>使用get、set、add、remove方法操作数组列表</p>
<p>如果数组存储的元素比较多，又经常需要在中间位置插入、删除元素，就应该考虑使用链表。</p>
<p>数组和数组列表比较：</p>
<p>*不必指出数组的大小</p>
<p>*使用add将任意多的元素添加到数组中</p>
<p>*使用size()代替length计算元素数目</p>
<p>*使用a.get(i)代替a[i]访问元素</p>
<p>3.2 类型化与原始数组列表的兼容性<br>鉴于兼容性的考虑，编译器在对类型转换进行检查之后，如果没有发现违反规则的现象，就将所有的类型化数组列表转换成原始数组列表。</p>
<p>在与遗留的代码进行交叉操作时，研究一下编译器的警告性提示，并确保这些警告不会造成太严重的后果就行了。</p>
<p>4 对象包装器与自动装箱<br>所有的基本类型都有一个与之对应的类，这些类称为包装器。</p>
<p>对象包装器类是不可变的，一旦构造了包装器，就不允许更改包装器的值。</p>
<p>对象包装器类是final类，不能定义他们的子类。</p>
<p>由于每个值分别包装在对象中，所以ArrayList<integer>的效率远远低于int[]数组。</integer></p>
<p>自动装箱：当将一个int值赋给Integer对象时</p>
<p>自动拆箱：当将一个Integer对象赋给一个int值时</p>
<p>装箱和拆箱是编译器认可的，而不是虚拟机。</p>
<p>使用数值对象包装器还有另一个好处：可以将某些基本方法放置在包装器中（Integer.parseInt(s)）</p>
<p>5 参数数量可变的方法<br>public PrintStream printf(String fmt,Object… args)</p>
<p>这里的…是Java代码的一部分，它表明这个方法可以接收任意数量的对象。</p>
<p>编译器会对方法进行转换，将可变参数绑定到Object[]数组上，并在有必要的时候进行自动装箱。</p>
<p>可以将已存在且最后一个参数是数组的方法重新定义为可变参数方法。</p>
<p>6 枚举类<br>public enum Size { SMALL，MEDIUM，LARGE};</p>
<p>这个声明定义了一个枚举类，它有四个实例。</p>
<p>比较两个枚举类型的值时，永远不要用equals，而直接使用==</p>
<p>所有的枚举类都是Enum类的子类</p>
<p>toString()-返回枚举常量名</p>
<p>valueOf()-toString()的逆方法</p>
<p>values()-返回一个包含全部枚举值的数组</p>
<p>ordinal()-返回枚举常量的位置</p>
<p>7 反射<br>反射机制可以用来：</p>
<p>*在运行时分析类的能力</p>
<p>*在运行时查看对象</p>
<p>*实现通用的数组操作代码</p>
<p>*利用Method对象</p>
<p>7.1 Class类<br>在程序运行期间，Java运行时系统始终为所有的对象维护一个被称为运行时的类型标识。这个信息跟踪着每个对象所属的类。虚拟机利用运行时类型信息选择相应的方法执行。</p>
<p>获取Class类的三种方式：</p>
<p>1.Object类中的getClass()方法将返回一个Class类型的实例。</p>
<p>Class c1 = e.getClass();</p>
<p>2.调用静态方法forName获得类名对应的Class对象;</p>
<p>Class c1=Class.forName(className);</p>
<p>3.如果T是任意的Java类型，T.class将代表匹配的类对象。</p>
<p>Class c1=Random.class;</p>
<p>最常用的Class方法是getName,这个方法将返回类的名字。</p>
<p>一个Class对象实际上表示的是一个类型，而这个类型未必一定是一种类。例如，int不是类，但int.class是一个Class类型的对象。</p>
<p>鉴于历史原因，数组类型的Class类调用getName方法会返回一个很奇怪的名字。</p>
<p>虚拟机为每个类型管理一个Class对象。可以利用==运算符实现两个类对象比较的操作。</p>
<p>if(e.getClass()==Employee.class)</p>
<p>newInstance()可以用来动态地创建一个类的实例(调用默认的构造器)。</p>
<p>e.getClass().newInstance();</p>
<p>将forName与newInstance配合起来使用，可以根据存储在字符串中的类名创建一个对象。</p>
<p> Class.forName(“java.util.Random”).newInstance();</p>
<p>如果需要向构造器中提供参数，需要使用Constructor类中的newInstance方法。</p>
<p>7.2 捕获异常<br>抛出异常比终止程序要灵活得多，这是因为可以提供一个”捕获“异常得处理器对异常情况进行处理。</p>
<p>异常有两种类型：未检查异常和已检查异常。对于已检查异常，编译器将会检查是否提供了处理器。对于未检查异常，编译器不会查看处理器。</p>
<p>最简单得处理器：将可能抛出已检查异常的一个或多个方法调用代码放在try块中，然后在catch子句中提供处理器代码。</p>
<p>Throwable是Exception类的超类。</p>
<p>7.3 利用反射分析类的能力<br>反射机制最重要的内容——检查类的结构</p>
<p>在java.lang.reflect包中有三个类Field、Method和Constructor，分别用于描述类的域、方法和构造器。</p>
<p>这三个类都有一个getName方法用来返回项目的名称，有一个getModifiers方法，返回一个整型数值，用不同的位开关描述public和static这样的修饰符使用情况。</p>
<p>Field类有一个getType方法用来返回描述域所属类型。</p>
<p>Method和Constructor类有能够报告参数类型的方法。</p>
<p>Method类还有一个可以报告返回类型的方法。</p>
<p>java.lang.reflect包中的Modifier类的静态方法也可以分析getModifiers返回的整型数值（isPublic、isPrivate或isFinal），还可以使用Modifier.toString方法将修饰符打印出来。</p>
<p>Class类中的getFields、getMethods和getConstructors方法将返回类提供的public域、方法和构造器数组，其中包括超类的公有成员。</p>
<p>Class类中的getDeclareFields、getDeclareMethods和getDeclaredConstructors方法将返回类中声明的全部域、方法和构造器，但不包括超类的成员。</p>
<p>7.4 在运行时使用反射分析对象<br>查看任意对象的数据域名称和类型：</p>
<p>1.获得对应的Class对象。</p>
<p>2.通过Class对象调用getDeclareFields</p>
<p>查看对象域的关键方法是Field类中的get方法。如果f是一个Field类型的对象，obj是某个包含f域的类的对象，f.get(obj)将返回一个对象，其值为obj域中与f同名的域的当前值。</p>
<p>Employee harry=new Employee(“Harry Hacker,35000,10,1,1989”);<br>Class c1=harry.getClass();<br>Field f=c1.getDeclaredField(“name”);<br>Object v=f.get(harry);<br>反射机制的默认行为受限于Java的访问控制。需要调用Field、Method或Constructor对象的setAccessible方法。</p>
<p>f.setAccessible(true)</p>
<p>setAccessible是AccessibleObject类中的一个方法，它是Field、Method和Constructor类的公共超类。</p>
<p>当然，可以获得就可以设置。调用f.set(obj,value)可以将obj对象的f域设置成新值。</p>
<p>下面是一个可供任意类使用的通用toString方法。</p>
<p>import java.lang.reflect.AccessibleObject;<br>import java.lang.reflect.Array;<br>import java.lang.reflect.Field;<br>import java.lang.reflect.Modifier;<br>import java.util.ArrayList;</p>
<p>public class ObjectAnalyzer<br>{<br>   private ArrayList<object> visited = new ArrayList&lt;&gt;();</object></p>
<p>   /**</p>
<pre><code>* Converts an object to a string representation that lists all fields.
* @param obj an object
* @return a string with the object&apos;s class name and all field names and
* values
*/
</code></pre><p>   public String toString(Object obj)<br>   {<br>      if (obj == null) return “null”;<br>      if (visited.contains(obj)) return “…”;<br>      visited.add(obj);<br>      Class cl = obj.getClass();<br>      if (cl == String.class) return (String) obj;<br>      if (cl.isArray())<br>      {<br>         String r = cl.getComponentType() + “[]{“;<br>         for (int i = 0; i &lt; Array.getLength(obj); i++)<br>         {<br>            if (i &gt; 0) r += “,”;<br>            Object val = Array.get(obj, i);<br>            if (cl.getComponentType().isPrimitive()) r += val;<br>            else r += toString(val);<br>         }<br>         return r + “}”;<br>      }</p>
<pre><code>String r = cl.getName();
// inspect the fields of this class and all superclasses
do
{
   r += &quot;[&quot;;
   Field[] fields = cl.getDeclaredFields();
   AccessibleObject.setAccessible(fields, true);
   // get the names and values of all fields
   for (Field f : fields)
   {
      if (!Modifier.isStatic(f.getModifiers()))
      {
         if (!r.endsWith(&quot;[&quot;)) r += &quot;,&quot;;
         r += f.getName() + &quot;=&quot;;
         try
         {
            Class t = f.getType();
            Object val = f.get(obj);
            if (t.isPrimitive()) r += val;
            else r += toString(val);
         }
         catch (Exception e)
         {
            e.printStackTrace();
         }
      }
   }
   r += &quot;]&quot;;
   cl = cl.getSuperclass();
}
while (cl != null);

return r;
</code></pre><p>   }<br>}<br>可以通过以下方式使用通用的toString方法实现自己类中的toString方法（实体类中的域使用基本类型）：</p>
<p>public String toString()<br>{<br>    return new ObjectAnalyzer().toString(this);<br>}<br>7.5 使用反射编写泛型数组代码<br>如何构造泛型数组？</p>
<p>考虑这样的问题：</p>
<p>一个Employee[]临时的转换成Object[]数组，然后再把它转换回来是可以的，但一个从开始就是Object[]的数组却永远不能转换成Employee[]数组。</p>
<p>因此，我们需要能够创建与原数组类型相同的新数组（需要java.lang.reflect包中的Array类的一些方法，其中关键的是Array类中的静态方法newInstance，它能够构造新数组）</p>
<p>Object newArray=Array.newInstance(componentType,newLength);</p>
<p>在调用这个方法时需要提供两个参数：</p>
<p>一个是数组的长度——Array.getLength(a)</p>
<p>一个是数组的元素类型——1.首先获得a数组的类对象；2.确认它是一个数组；3.使用Class类的getComponentType方法确定数组对应的类型。</p>
<p>下面是一个可扩展任意类型数组的方法：</p>
<p>public static Object goodCopyOf(Object a, int newLength)<br>   {<br>      Class cl = a.getClass();<br>      if (!cl.isArray()) return null;<br>      Class componentType = cl.getComponentType();<br>      int length = Array.getLength(a);<br>      Object newArray = Array.newInstance(componentType, newLength);<br>      System.arraycopy(a, 0, newArray, 0, Math.min(length, newLength));<br>      return newArray;<br>   }<br>此处将参数声明为Object类型而不是Object[]类型的原因是：整型数组类型int[]可以被转换成Object，而不能转换成对象数组。</p>
<p>7.6 调用任意方法<br>反射机制允许调用任意方法</p>
<p>类似于Field类的get方法查看对象域过程，在Method类中有一个invoke方法，它允许调用包装在当前Method对象中的方法。</p>
<p>invoke方法的签名：</p>
<p>Object invoke(Object obj,Object… args)</p>
<p>第一个参数是隐式参数，其余参数是显示参数，对于静态方法，第一个参数可以被忽略，即设置为null。</p>
<p>例如：m1.invoke(harry)——m1是Employee的getName方法（非静态方法）</p>
<p>　　　 f.invoke(null,6)——f是Math类的sqrt方法（静态方法）</p>
<p>如何获得Method对象：</p>
<p>通过Class类中的getMethod方法得到想要的方法，于getField类似（getField方法根据表示域名的字符串，返回一个Field对象），注意，有可能存在若干个相同名字的方法，所以还必须提供想要的方法的参数类型。</p>
<p>getMethod方法的签名：</p>
<p>Method getMethod(String name,Class… parameterTypes)</p>
<p>例如： Method m1=Employee.class.getMethod(“raiseSalary”,double.class);</p>
<p>使用反射获得方法指针的代码要比仅仅直接调用方法明显慢一些，有鉴于此，建议仅在必要的时候才使用Method对象，而最好使用接口以及lambda表达式。</p>
<p>特别要重申：建议Java开发者不要使用Method对象的回调功能。使用接口进行回调会使得代码的执行速度更快，更易维护。</p>
<p>7.8 继承的设计技巧<br>1.将公共操作和域放在超类</p>
<p>2.不要使用受保护的域</p>
<p>3.使用继承实现“is-a”关系</p>
<p>4.除非所有的继承方法都有意义，否则不要使用继承</p>
<p>5.在覆盖方法时，不要改变预期的行为</p>
<p>6.使用多态，而非类型信息</p>
<p>　　if(x is of type 1)</p>
<p>　　　　action1(x);</p>
<p>　　else if(x is of type 2)</p>
<p>　　　　action2(x);</p>
<p>　　考虑使用多态。</p>
<p>　　使用多态方法或接口编写的代码比使用对多种类型进行检测的代码更加易于维护和扩展。</p>
<p>7.不要过多的使用反射</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/09/Java核心技术-继承/" data-id="cjlv1o7ie0005gc7ipqm68p6t" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java核心技术-对象与类" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/05/Java核心技术-对象与类/" class="article-date">
  <time datetime="2018-09-05T12:08:41.000Z" itemprop="datePublished">2018-09-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/05/Java核心技术-对象与类/">Java核心技术-对象与类</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1 面向对象程序设计概述<br>面向对象的程序是由对象组成的，每个对象包含对用户公开的特定功能部分和隐藏的实现部分。</p>
<p>1.1 类<br>类是构造对象的模板或蓝图，由类构造对象的过程称为创建类的实例。</p>
<p>封装：　</p>
<p>从形式上看，是将数据和行为组合在一个包中，并对对象的使用者隐藏了数据的实现方式。</p>
<p>对象中的数据称为实例域，操纵数据的过程称为方法。</p>
<p>对于每个特定类实例（对象）都有一组特定的实例域值，这些值的集合就是这个对象的当前状态。</p>
<p>实现封装的关键在于绝对不能让类中的方法直接地访问其它类的实例域，程序仅能通过对象的方法与对象数据进行交互。</p>
<p>在Java中，所有类都源于一个“神通广大的超类”，它就是Object。</p>
<p>通过扩展一个类来建立另一个类的过程称为继承。</p>
<p>1.2 对象<br>对象的三个主要特性：</p>
<p>对象的行为——可以对对象施加哪些操作，或可以对对象施加哪些方法。</p>
<p>对象的状态——当施加那些方法时，对象如何响应。</p>
<p>对象的标识——如何辨别具有相同行为与状态的不同对象。</p>
<p>1.3 识别类<br>识别类的简单规则是在分析问题的过程中寻找名词，而方法对应着动词。</p>
<p>1.4 类之间的关系<br>在类之间，最常见的关系有</p>
<p>*依赖（“uses-a”)：一个类的方法操纵另一个类的对象，我们就说一个类依赖于另一个类。减少依赖即减少耦合。</p>
<p>*聚合（”has-a”）：类A的对象包含类B的对象。</p>
<p>*继承（”is-a”）：用于表示特殊与一般关系的。</p>
<p>2 使用预定义类<br>2.1 对象与对象变量<br>要想使用对象，就必须首先构造对象，并指定其初始状态。构造器是一种特殊的方法，用来构造并初始化对象。</p>
<p>构造器的名字应该与类名相同。</p>
<p>明白对象与对象变量之间的区别。</p>
<p>一定要认识到：一个对象变量并没有实际包含一个对象，而仅仅引用一个对象。任何对象变量的值都是对存储在另外一个地方的一个对象的引用。</p>
<p>局部变量不会自动初始化为null，而必须通过调用new或将他们设置为null进行初始化。</p>
<p>2.2 LocalDate类<br>Java中，Date类用来表示时间点，LocalDate类用来表示日历表示法。</p>
<p>不要使用构造器来构造LocalDate类，应该使用静态工厂方法代表你调用构造器：LocalDate.now()会构造一个表示构造这个对象时的日期对象。</p>
<p>2.3 更改器方法与访问器方法<br>类似于String类的toUpperCase方法，调用这个方法时原对象不变，会返回一个将原对象中所有字符大写的新对象。</p>
<p>相比较而言，那些会更改原对象状态的方法称为更改器方法。（GregorianCalendar.add）</p>
<p>访问器方法：只访问对象而不修改对象的方法。</p>
<p>3.用户自定义类<br>实例域（private）+实例方法</p>
<p>3.1 构造器<br>*构造器与类同名</p>
<p>*每个类可以有一个以上的构造器</p>
<p>*构造器可以有0、1个或多个参数</p>
<p>*构造器没有返回值</p>
<p>*构造器总是伴随着new操作一起调用</p>
<p>3.2 隐式参数与显示参数<br>一般方法有两种参数，第一种参数称为隐式参数，出现在方法名前的类对象。第二种显示参数是位于方法名后面括号中的数值。</p>
<p>在每一个方法中，关键字this表示隐式参数。</p>
<p>3.3 封装的优点<br>*一个私有的数据域</p>
<p>*一个公有的域访问器方法</p>
<p>*一个公有的域更改器方法</p>
<p>注意不要编写返回引用可变对象的访问器方法，如果需要返回一个可变对象的引用，应该首先对它进行克隆。</p>
<p>public Date getHireDay(){</p>
<p>　　return (Date)hireDay.clone();</p>
<p>}</p>
<p>3.4 基于类的访问权限<br>一个方法可以访问所属类的所有对象的私有域数据。</p>
<p>3.5 final实例域<br>final修饰符大都应用于基本类型域，或不可变类的域。<br>对于可变的类,final关键字只表示存储在可变类对象中的对象引用不会再指向其它类对象，不过这个对象仍可以更改。（StringBuilder）</p>
<p>4 静态域与静态方法<br>4.1 静态域（类域）<br>如果将域定义为static，那么每个类中只有一个这样的域。即使没有一个类对象存在，静态域也存在。它属于类，而不属于任何独立的对象。</p>
<p>4.2 静态常量<br>Math.PI、System.out</p>
<p>公有常量只能访问不能修改：public final</p>
<p>system类有一个setOut方法看，可以将System.out（final变量）设置为不同的流，因为setOut方法是一个本地方法，不是用Java语言实现的，可以绕开Java语言的存取控制机制。</p>
<p>4.3 静态方法<br>静态方法是一种不能向对象实施操作的方法。</p>
<p>静态方法不能访问类的实例域，但是可以访问自身类中的静态域。</p>
<p>使用静态方法的两种情况：</p>
<ul>
<li><p>一个方法不需要访问对象状态，其所需的参数都是通过显示参数提供（Math.pow）</p>
</li>
<li><p>一个方法只需要访问类的静态域</p>
</li>
</ul>
<p>4.4 工厂方法<br>静态方法还有另一种常见的用途：静态工厂方法——不通过 new，而是用一个静态方法来对外提供自身实例的方法</p>
<p>静态工厂构造对象和构造器构造对象的主要区别（更灵活）：</p>
<p>1.可以命名构造器名称</p>
<p>2.不用每次被调用时都创建新对象</p>
<p>3.可以返回原返回类型的子类</p>
<p>5 方法参数<br>参数传递给方法的两种方式：按值调用和按引用调用。</p>
<p>一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。</p>
<p>Java采用按值调用。</p>
<p>方法参数两种类型：</p>
<p>*基本数据类型</p>
<p>*对象引用</p>
<p>Java中方法参数的使用情况：</p>
<p>*一个方法不能修改一个基本数据类型的参数</p>
<p>*一个方法可以改变一个对象参数的状态</p>
<p>*一个方法不能让对象参数引用一个新的对象</p>
<p>6 对象构造<br>6.1 重载<br>由编译器进行重载解析。</p>
<p>方法签名：要完整地描述一个方法，需要指出方法名以及参数类型。（返回类型不是方法签名的一部分）</p>
<p>6.2 默认域初始化<br>如果在构造器中没有显式地给域赋予初值，那么就会被自动地赋为默认值：数值为0、布尔值为false、对象引用为null。</p>
<p>这是域与局部变量的主要不同点——局部变量没有默认初始化，必须显示的初始化局部变量。</p>
<p>6.3 无参数构造器<br>如果类中提供了至少一个构造器，但是没有提供无参数的构造器，则在构造对象时没有提供参数就会被认为不合法。</p>
<p>仅当类中没有提供任何构造器，系统才会提供一个默认构造器。</p>
<p>6.4 调用另一个构造器<br>如果构造器的第一个语句形如this()，这个构造器将调用同一个类的另一个构造器。</p>
<p>6.5 初始化块<br>初始化数据域的方法：</p>
<p>1.在构造器中设置值</p>
<p>2.在声明中赋值</p>
<p>3.初始化块</p>
<p>调用构造器初始化的步骤：</p>
<p>所有数据域被初始化为默认值（静态域初始化）-&gt;数据域初始化语句-&gt;初始化块-&gt;构造器</p>
<p>6.6 对象析构器与finalize方法<br>finalize方法将在垃圾回收器清除对象之前调用。</p>
<p>如果某个资源需要在使用完毕后立刻关闭，可以应用一个close方法来完成相应的清理操作。</p>
<p>7 包<br>使用包的主要原因是确保类名的唯一性。</p>
<p>7.1 类的导入<br>一个类可以使用所属包中的所有类，以及其它包中的公有类。</p>
<p>只能使用星号（<em>）导入一个包，而不能使用import java.</em>或import java.<em>.</em>导入以java为前缀的所有包。</p>
<p>可以采用增加一个特定的包名解决两个包中共有类的引用问题。</p>
<p>如果两个包中的两个相同名称的类都要引用，可以在每个类名前加上完整的包名。</p>
<p>7.2 静态导入<br>import语句不仅可以导入类，还增加了导入静态方法和静态域的功能。</p>
<p>7.3 将类放入包中<br>编译器对文件（带有文件分隔符和扩展名.java的文件）进行操作。而Java解释器加载类（带有.分隔符)</p>
<p>7.4 包作用域<br>标记为public的部分可以被任意的类使用；标记为private的部分只能被定义它们的类使用。如果没有指定public或private，这个部分（类、方法、变量）可以被同一个包中的所有方法访问。</p>
<p>8 类设计技巧<br>1.一定要保证数据私有</p>
<p>2.一定要对数据初始化</p>
<p>3.不要在类中使用过多的基本类型</p>
<p>4.不是所有的域都需要独立的域访问器和域更改器</p>
<p>5.将职责过多的类进行分解</p>
<p>6.类名和方法名要能体现它们的职责</p>
<p>7.优先使用不可变的类（考虑具体情况）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/05/Java核心技术-对象与类/" data-id="cjlv1o7ib0003gc7ipcw0g7xd" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java核心技术-Java的基本程序设计结构" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/03/Java核心技术-Java的基本程序设计结构/" class="article-date">
  <time datetime="2018-09-03T02:24:32.000Z" itemprop="datePublished">2018-09-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/03/Java核心技术-Java的基本程序设计结构/">Java核心技术-Java的基本程序设计结构</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.一个简单的Java应用程序<br>public class FirstSample<br>{<br>    public static void main(String[] args)<br>    {<br>        System.out.pringln(“We will not use ‘Hello,World!’”);<br>    }<br>}<br>这个程序虽然简单，但所有的Java应用程序都具有这种结构：</p>
<p>首先，Java区分大小写（如将main写成Main程序将无法运行）</p>
<p>下面逐行分析这段代码：</p>
<p>　　public关键字称为访问修饰符，用于控制程序的其它部分对这段代码的访问级别。</p>
<p>　　class关键字表明Java程序中的全部内容都包含在类中。</p>
<p>　　类名紧跟在class关键字后面，名字必须以字母开头，后面可以跟字母和数字的任意组合，不能使用Java关键字</p>
<p>　　static关键字修饰的方法称为类方法</p>
<p>　　void关键字表示无返回类型</p>
<p>标准的命名规范——骆驼命名法</p>
<p>源代码的文件名必须与类名相同</p>
<p>2.注释<br>1.// 　　最常用的注释方式，其注释内容从//开始到本行结尾</p>
<p>2./<em>和</em>/ 用于长篇注释，将注释内容放在/<em>和</em>/中间</p>
<p>3./<strong>和*/用来生成自动文档，将注释内容放在/</strong>和*/中间</p>
<p>3.数据类型<br>Java是一种强类型语言，必须为每一个变量声明一种类型。</p>
<p>基本数据类型：4种整型、2种浮点型、1种字符型、一种布尔型</p>
<p>3.1 整型<br>从Java7开始，加上前缀0b或0B就可以写二进制数。（0b1001表示9）</p>
<p>从Java7开始，还可以为数字字面量加下划线（1_000_000表示100万）</p>
<p>3.2 浮点类型<br>三种特殊的浮点数值：正无穷大（一个正整数除以0）、负无穷大、NaN（不是一个数字，如0/0或者负数的平方根）</p>
<p>不能用x==Double.NaN检测x是否等于Double.NaN,可以使用Double.isNaN(x)检测</p>
<p>2.0-1.1将打印出0.899999999999，如果数值在计算中不允许有任何误差，就应该用BigDecimal类</p>
<p>3.3 char类型<br>char类型的字面量要用单引号括起来</p>
<p>有些Unicode字符可以用一个char值描述，另外一些Unicode字符则需要两个char值</p>
<p>3.4 boolean类型<br>用来判定逻辑条件：true/false</p>
<p>4.变量<br>4.1 变量<br>变量名必须是一个以字母开头并由字母（包括”_“、”$”）或数字构成的序列.</p>
<p>声明一个变量后，必须用赋值语句对变量进行显式的初始化。</p>
<p>变量的声明尽可能地靠近变量第一次使用的地方是一种良好的编程风格</p>
<p>4.2 常量<br>final关键字用于指示常量（习惯上常量名使用全大写）</p>
<p>static final设置一个类常量</p>
<p>5.运算符<br>strictfp关键字标记的方法必须使用严格的浮点计算来生成可再生的结果（有可能产生溢出）</p>
<p>5.1数学函数<br>floorMod方法是解决整数求余的问题</p>
<p>在Math类中，为了达到最快的性能，所有方法都使用计算机浮点单元中的例程，如果得到一个完全可预测的结果比运算速度更重要的话，应该使用StrictMath类。</p>
<p>5.2 数值类型之间的转换</p>
<p>转换顺序：double-&gt;float-&gt;long-&gt;int</p>
<p>int转float失效原因（<a href="https://blog.csdn.net/m1n_love/article/details/55224990）" target="_blank" rel="noopener">https://blog.csdn.net/m1n_love/article/details/55224990）</a></p>
<p>5.3 强制类型转换<br>对浮点数进行舍入运算：Math.round</p>
<p>5.4 结合赋值和运算符<br>x+=4;</p>
<p>5.5 自增与自减运算符<br>5.6 关系和boolean运算符<br>==、!=、&amp;&amp;、||（短路）、x&lt;y?x:y;</p>
<p>5.7 位运算符<br>&amp;、|（不短路）、^、~、&gt;&gt;、&lt;&lt;（移位操作要进行模32操作或64）</p>
<p>5.8 括号与运算符级别</p>
<p>5.9 枚举类型<br>enum Size{ SMALL,MEDIUM,LARGE,EXTRA_LARGE}</p>
<p>Size s=Size.MEDIUM</p>
<p>6 字符串<br>Java没有内置的字符串类型，而是在标准Java类库中提供了一个预定义类，叫做String</p>
<p>6.1 子串<br>String类的substring方法</p>
<p>6.2 拼接<br>1.使用+号连接：当一个字符串与一个非字符串拼接时，后者会被转换成字符串（任何一个Java对象都能被转换成字符串）</p>
<p>2.如果需要把多个字符串放在一起，用一个定界符分隔，可以使用静态join方法：String.join(“/“,”S”,”M”,”L”,”XL”)；</p>
<p>6.3 不可变字符串<br>String类没有提供修改字符串的方法，因此Java文档中将String类对象称为不可变字符串。</p>
<p>不可变字符串有一个优点：编译器可以让字符串共享</p>
<p>Java设计者认为共享带来的高效率远远胜过于提取、拼接字符串所带来的低效率</p>
<p>6.4 检测字符串是否相等<br>使用equals而不要使用==</p>
<p>如果虚拟机始终将相同的字符串共享，就可以使用==运算符检测是否相等。但实际上只有字符串常量是共享的，而+或substring等操作产生的结果并不是共享的，当使用==运算符测试字符串相等时，从表面上看，这种bug很像随机产生的间歇性错误。</p>
<p>6.5 空串与null串<br>if(str != null &amp;&amp; str.length != 0) 首先检查str不为null</p>
<p>6.6 码点与代码单元<br>不要使用char数据类型（代码单元）来保存从字符串中取出的码点</p>
<p>6.7 构建字符串<br>构建字符串时如果采用字符串连接的方式，每次连接字符串都会构建一个新的String对象，既耗时，又浪费空间。使用StringBuilder类可以避免这个问题发生（单线程）。</p>
<p>StringBuffer类较StringBuilder类效率稍低，但允许在多线程中使用。</p>
<p>7 输入输出<br>7.1 读取输入<br>输入可见：Scanner in=new Scanner(System.in);</p>
<p>输入不可见：Console cons=System.console();</p>
<p>　　　　　　String username=cons.readLine(“User name:”);</p>
<p>　　　　　　char[] passwd=cons.readPassword(“Password:”);——每次只能读取一行输入，而没有能读取一个单词或一个数值的方法</p>
<p>7.2 格式化输出<br>System.printf(“Hello,%s. Next year,you’ll be %d”,name,age);</p>
<p>每一个以%开始的格式说明符都用相应的参数替换</p>
<p>String date=String.format(“%1$s %2$tB %2$te,%2$tY”,”Due date:”,new Date());</p>
<p>格式说明符的语法图：</p>
<p>7.3 文件输入与输出<br>如果文件名中包含反斜杠符号，就要记住在每个反斜杠前加一个额外的反斜杠：”c:\mydirectory\myfile.txt”</p>
<p>查找文件路径：String dir=System.getProperty(“user.dir”);</p>
<p>8 控制流程<br>Java使用条件语句和循环结构确定控制流程</p>
<p>8.1 块作用域<br>块是指由一对大括号括起来的若干条简单的Java语句，块确定了变量的作用域。</p>
<p>8.2 条件语句<br>if/else</p>
<p>8.3 循环语句<br>while/do-while</p>
<p>8.4 确定循环<br>在循环中，检测两个浮点数是否相等需要格外小心：</p>
<p>for(double x=0;x!=10;x+=0.1) 因为0.1无法精确的使用二进制表示，所以循环可能永远无法结束</p>
<p>8.5 多重选择<br>switch</p>
<p>8.6 中断控制流程语句<br>Java中增加了一条带标签的break，用于跳出多重循环。</p>
<p>对于任何使用break语句的代码都需要检测循环是正常结束还是由break跳出。</p>
<p>9 大数值<br>大数值可以处理包含任意长度数字序列的数值</p>
<p>BigInteger（任意精度整数）和BigDecimal（任意精度浮点数）</p>
<p>lotterOdds=lotterOdds.multiply(BigInteger.valueOf(n-i+1).divide(BigInteger.valueOf(i));</p>
<p>10 数组<br>数组是一种数据结构，用来存储同一类型值得集合。</p>
<p>数字数组所有元素初始化为0；Boolean数组元素会初始化为false；对象数组得元素会初始化为null。</p>
<p>获得数组中的元素个数：array.length</p>
<p>一旦创建了数组，就不能改变它的大小。如果经常需要在运行中扩展数组的大小，就应该使用数组列表(ArrayList)。</p>
<p>要打印数组可以使用Arrays.toString(a);</p>
<p>10.1 增强for循环<br>for each循环可以用来依次处理数组中的每个元素(无需使用下标)</p>
<p>10.2 数组初始化以及匿名数组<br>数组的初始化：</p>
<p>int[] smallPrimes={2,3,5,6,11};</p>
<p>使用匿名数组可以在不创建新变量的情况下重新初始化一个数组。</p>
<p>smallPrimes=new int[]{17,18,23,29,31};</p>
<p>10.3 数组拷贝<br>一个数组变量拷贝给另一个数组变量：这时两个变量将引用同一个数组。</p>
<p>int[] luckyNumbers=smallPrimes;</p>
<p>一个数组的值拷贝给另一个数组：使用Arrays.copyOf方法:</p>
<p>int[] copiedLuckyNumbers=Arrays.copyOf(luckyNumbers,2*luckyNumbers.length);</p>
<p>10.4 命令行参数<br>10.5 数组排序<br>对数值型数组进行排序可以使用Arrays类中的sort方法，这个方法使用了优化的快速排序算法。</p>
<p>10.6 二维数组<br>多维数组将使用多个下标访问数组元素，它适用于表示表格或更加复杂的排列形式。</p>
<p>遍历二维数组：</p>
<p>for(int i=0;i&lt;balances.length;i++)</p>
<p>{</p>
<p>　　for(int j=0;j&lt;balances[i].length;j++)</p>
<p>　　{ … 　　}</p>
<p>}</p>
<p>for each循环语句不能自动处理二维数组的每一个元素，需要使用两个嵌套循环</p>
<p>要想快速打印一个二维数组的数据元素列表，可以调用：Arrays.deepToString(a));</p>
<p>10.6 不规则数组<br>Java实际上没有多维数组，只有一维数组，多维数组被解释为“数组的数组”</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/03/Java核心技术-Java的基本程序设计结构/" data-id="cjlv1o7i10000gc7imyhofbli" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-第2章—Java内存区域与内存溢出异常" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/01/第2章—Java内存区域与内存溢出异常/" class="article-date">
  <time datetime="2018-09-01T15:51:26.000Z" itemprop="datePublished">2018-09-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/01/第2章—Java内存区域与内存溢出异常/">第2章—Java内存区域与内存溢出异常</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>2.1 概述<br>总结：本章将从概念上介绍 Java 虚拟机内存的各个区域，讲解这些区域的作用、服务对象以及其中可能产生的问题。</p>
<p>2.2 运行时数据区域<br>Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存划分为若干个不同的数据区域，这些区域都有各自的用途以及创建和销毁时间</p>
<p>2.2.1 程序计数器（线程私有）<br>由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任意一个确定的时刻，一个处理器都只会执行一条线程中的指令。因此，为了线程切换后能回复到正确的执行位置，每条线程都需要有一个独立的程序计数器。</p>
<p>如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址； 如果线程正在执行的是 Native 方法，这个计数器值则为空。</p>
<p>可能出现的异常：此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域</p>
<p>2.2.2 Java 虚拟机栈（线程私有）<br>Java 虚拟机栈描述的是Java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p>
<p>局部变量表存放了编译期可知的各种数据类型、对象引用和 returnAddress 类型，且它所需的内存空间在编译期间完成分配，在方法运行期间不会改变局部变量表的大小。</p>
<p>可能出现的异常：1.线程请求的栈深度大于虚拟机所允许的深度，StackOverflowError</p>
<p>　　　　　　　　2.如果虚拟机栈可以动态扩展，但扩展时无法申请到足够的内存，OutOfMemoryError</p>
<p>2.2.3 本地方法栈（线程私有）<br>本地方法栈与虚拟机栈的作用类似，区别是虚拟机栈为虚拟机执行 Java 方法服务，本地方法栈则为虚拟机执行Native方法服务。Sun Hotspot 直接将本地方法栈和虚拟机栈合二为一。</p>
<p>可能出现的异常：StackOverflowError、OutOfMemoryError</p>
<p>2.2.4 Java 堆（线程共享）<br>所有对象实例以及数组都要在堆上分配，Java 堆在虚拟机启动时创建，此内存的唯一目的就是存放对象实例，Java 堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。</p>
<p>可能出现的异常：当在堆中没有内存可以完成实例分配，并且堆也无法再扩展时，OutOfMemoryError。</p>
<p>2.2.5 方法区（线程共享）<br>方法区用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，这区域的内存回收目标主要是针对常量池的回收和对类型的卸载。</p>
<p>可能出现的异常：当方法区无法满足内存分配需求时，OutOfMemoryError</p>
<p>2.2.6 运行时常量池<br>运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项就是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p>
<p>一般来说，除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。</p>
<p>运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，运行期间也可能将新的常量放入池中（如 String 类的 intern() 方法）</p>
<p>可能出现的异常：当常量池无法再申请到内存时会抛出OutOfMemoryError</p>
<p>2.2.7 直接内存<br>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域。Jdk1.4中新加入了NIO类，引入了一种基于通道与缓冲区的I/O方式，它可以使用 Native 函数库直接分配对外内存，然后通过一个存储在 Java 堆中的DirectByteBuffer对象作为这块内存的引用进行操作，避免了在Java堆和Native堆中来回复制数据，在一些场景中显著提高性能。</p>
<p>直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，肯定会受到本机总内存大小和处理器寻址空间的限制。</p>
<p>服务器管理员在配置虚拟机参数时，会根据实际内存设置 -Xmx 等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制，从而导致动态扩展时出现OutOfMemoryError异常</p>
<p>2.3 HotSpot 虚拟机对象探秘<br>根据上述知识，我们已经了解到虚拟机内存划分为哪几块以及这些块中都分别存放哪些内容，再来了解虚拟机内存中数据的其他细节，例如它们是如何创建、如何布局以及如何访问的，下面将深入探讨 HotSpot 虚拟机在 Java 堆中对象创建、布局和访问的全过程。</p>
<p>2.3.1 对象的创建<br>在语言层面上，创建对象（例如克隆和反序列化）通常仅仅是一个new 关键字而已，而在虚拟机中，对象（普通对象，不包括数组和Class对象等）的创建又是怎样的一个过程呢？</p>
<p>1.虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，必须先执行相应的类加载过程。</p>
<p>2.在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可完全确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来（两种方式：1.指针碰撞； 2.空闲列表），选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定，因此，使用Serial、ParNew等待Compact 过程的收集器时系统采用指针碰撞分配算法，而使用CMS 这种基于Mark-Sweep算法的收集器时，通常使用空闲列表。为确保内存分配时的线程安全，通常使用两种解决方案：一种是对分配内存空间的动作进行同步处理——实际上虚拟机采用CAS 配上失败重试的方式保证更新操作的原子性；另一种是把内存分配的动作按照线程划分在不同的空间之中，即每个线程在Java 堆中预先分配一小块内存，称为本地线程分配缓冲（TLAB），哪个线程要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完并分配新的TLAB时，才需要同步锁定。</p>
<p>3.内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值，如果使用TLAB，这一工作可以提前至TLAB分配时进行。这一步操作保证了对象的实例字段在Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p>
<p>4.接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例，如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头之中。</p>
<p>5.在上面工作都完成之后，从虚拟机的角度来看，一个新对象已经产生，但从Java程序的角度来看，对象的创建才刚刚开始。一般来说，执行new 指令之后会接着执行<init>方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</init></p>
<p>2.3.2 对象的内存布局<br>在HotSpot 虚拟机中，对象在内存中存储的布局可以分为 3 块区域：对象头、实例数据和对齐填充。</p>
<p>1.HotSpot 虚拟机的对象头包括两部分信息：</p>
<p>第一部分用于存储对象自身的运行时数据（如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等），官方称为“Mark Word”。Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间</p>
<p>第二部分是类型指针（并不是所有虚拟机都有），即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例（句柄和直接指针）。另外，如果对象是一个Java 数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java 对象的元数据信息确定Java 对象的大小，但是从数组的元数据中却无法确定数组的大小。</p>
<p>2.实例数据部分是对象真正存储的有效信息，也是在程序代码中定义的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录下来。这部分的存储顺序会受到虚拟机分配策略参数和字段在Java源码中定义的顺序的影响。HotSpot 虚拟机默认的分配策略是相同宽度的字段总是被分配到一起，满足这个前提条件下，在父类中定义的变量会出现在子类之前。</p>
<p>3.对齐填充部分并不是必然存在的，它仅仅起着占位符的作用。由于HotSpot 虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p>
<p>2.3.3 对象的访问定位<br>建立对象是为了使用对象，Java 程序需要通过栈上的 reference 数据来操作堆上的具体对象。目前主流的访问方式有使用句柄和直接指针两种。</p>
<p>1.如果使用句柄访问的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄池地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。</p>
<p>2.如果使用直接指针访问，那么Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象地址。</p>
<p>这两种对象访问方式各有优势，使用句柄来访问的最大好处就是 reference 中存储的是稳定的句柄地址；使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销。</p>
<p>Sun HotSpot 使用的是第二种方式进行对象访问。</p>
<p>2.4 实战： OutOfMemoryError 异常<br>在Java 虚拟机规范的描述中，除了程序计数器外，虚拟机内存的其他几个运行时数据区都有发生OutOfMemoryError（OOM）异常的可能。</p>
<p>本节主要内容有两个：</p>
<p>第一，通过代码验证Java 虚拟机规范中描述的各个运行时数据区存储的内容；</p>
<p>第二，在遇到实际的内存溢出异常时，能根据异常的信息快速判断是哪个区域的内存溢出，知道什么样的代码可能会导致这些区域内存溢出，以及出现这些异常后该如何处理。</p>
<p>2.4.1 Java 堆溢出（产生大量对象）<br>Java 堆用来存储对象实例，只要不断地创建对象，并且保证 GC Roots 到对象之间有可达路径来避免垃圾回收机制清楚这些对象，那么在对象数量达到最大堆的容量限制后就会产生内存溢出异常。</p>
<p>将堆的最小值 -Xms 参数与最大值 -Xmx参数设置为一样即可避免堆自动扩展。</p>
<p>Java 堆内存的 OOM 异常是实际应用中常见的内存溢出异常情况。当出现 Java 堆内存溢出时，异常信息栈信息 “java.lang.OutOfMemoryError” 会跟着进一步提示 “Java heap space” 。</p>
<p>要解决这个区域的异常，一般的手段是先通过内存映像分析工具对Dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是分清楚到底出现了内存泄漏还是内存溢出。如果是内存泄漏，可进一步通过工具查看泄漏对象到 GC Roots 的引用链；如果不存在泄漏，就是内存中的对象都必须存活着，那就应当检查虚拟机参数与机器物理内存对比看是否可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。</p>
<p>2.4.2 虚拟机栈和本地方法栈溢出（递归方法）<br>由于HotSpot 虚拟机并不区分虚拟机栈和本地方法栈，所以两种情况一并说明。</p>
<p>1.线程请求的栈深度大于虚拟机所允许的深度，StackOverflowError</p>
<p>2.如果虚拟机栈可以动态扩展，但扩展时无法申请到足够的内存，OutOfMemoryError</p>
<p>结论：</p>
<p>在单线程情况下，无论是由于栈帧太大还是虚拟机栈容量太小，当内存无法分配的时候，虚拟机抛出的都是StackOverflowError异常</p>
<p>在多线程情况下，每个线程的栈分配的内存越大，越容易产生内存溢出异常</p>
<p>2.4.3 方法区和运行时常量池溢出（产生大量类）<br>方法区用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。对于这个区域的测试，基本思路是运行大量的类去填满方法区，直到溢出。</p>
<p>方法区溢出也是一种常见的内存溢出异常，当出现 Java 方法区内存溢出时，异常信息栈信息 “java.lang.OutOfMemoryError” 会跟着进一步提示 “PermGen space” ，一个类要被垃圾收集器回收掉，判定条件是比较苛刻的。</p>
<p>2.4.4 本机直接内存溢出<br>DirectMemory容量可通过 -XX: MaxDirectMemorySize 指定，如果不指定，则默认与 Java 堆最大值一样。</p>
<p>由 DirectMemory 导致的内存溢出的一个很明显的特征是在Heap Dump文件中不会看见明显的异常，如果发现OOM后Dump文件很小，而程序中又直接或间接使用了NIO，那就可以考虑是否是DirectMemory 导致。</p>
<p>2.5 本章总结<br>通过本章的学习，我们明白了虚拟机中的内存是如何划分的，哪部分区域、什么样的代码和操作可能导致内存溢出异常。虽然Java 有垃圾收集机制，但内存溢出异常离我们仍然并不遥远，本章知识说明了各个区域出现内存溢出异常的原因。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/01/第2章—Java内存区域与内存溢出异常/" data-id="cjlv1o7ii0008gc7ihac73tro" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java-的静态工厂方法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/29/Java-的静态工厂方法/" class="article-date">
  <time datetime="2018-08-29T13:11:14.000Z" itemprop="datePublished">2018-08-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/29/Java-的静态工厂方法/">Java 的静态工厂方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>序：什么是静态工厂方法<br>Effective Java<br>2.1 静态工厂方法与构造器不同的第一优势在于，它们有名字<br>2.2 第二个优势，不用每次被调用时都创建新对象<br>2.3 第三个优势，可以返回原返回类型的子类<br>2.4 第四个优势，在创建带泛型的实例时，能使代码变得简洁<br>除此之外<br>3.1 可以有多个参数相同但名称不同的工厂方法<br>3.2 可以减少对外暴露的属性<br>3.3 多了一层控制，方便统一修改<br>总结</p>
<ol>
<li><p>序：什么是静态工厂方法<br>在 Java 中，获得一个类实例最简单的方法就是使用 new 关键字，通过构造函数来实现对象的创建。<br>就像这样：</p>
<p> Fragment fragment = new MyFragment();<br> // or<br> Date date = new Date();<br>不过在实际的开发中，我们经常还会见到另外一种获取类实例的方法：</p>
<p> Fragment fragment = MyFragment.newIntance();<br> // or<br> Calendar calendar = Calendar.getInstance();<br> // or<br> Integer number = Integer.valueOf(“3”);<br>↑ 像这样的：不通过 new，而是用一个静态方法来对外提供自身实例的方法，即为我们所说的静态工厂方法(Static factory method)。</p>
</li>
</ol>
<p>知识点：new 究竟做了什么?</p>
<p>简单来说：当我们使用 new 来构造一个新的类实例时，其实是告诉了 JVM 我需要一个新的实例。JVM 就会自动在内存中开辟一片空间，然后调用构造函数来初始化成员变量，最终把引用返回给调用方。</p>
<ol start="2">
<li>Effective Java<br>在关于 Java 中书籍中，《Effective Java》绝对是最负盛名几本的之一，在此书中，作者总结了几十条改善 Java 程序设计的金玉良言。其中开篇第一条就是『考虑使用静态工厂方法代替构造器』，关于其原因，作者总结了 4 条（第二版），我们先来逐个看一下。</li>
</ol>
<p>2.1 静态工厂方法与构造器不同的第一优势在于，它们有名字<br>由于语言的特性，Java 的构造函数都是跟类名一样的。这导致的一个问题是构造函数的名称不够灵活，经常不能准确地描述返回值，在有多个重载的构造函数时尤甚，如果参数类型、数目又比较相似的话，那更是很容易出错。</p>
<p>比如，如下的一段代码 ：</p>
<p>Date date0 = new Date();<br>Date date1 = new Date(0L);<br>Date date2 = new Date(“0”);<br>Date date3 = new Date(1,2,1);<br>Date date4 = new Date(1,2,1,1,1);<br>Date date5 = new Date(1,2,1,1,1,1);<br>—— Date 类有很多重载函数，对于开发者来说，假如不是特别熟悉的话，恐怕是需要犹豫一下，才能找到合适的构造函数的。而对于其他的代码阅读者来说，估计更是需要查看文档，才能明白每个参数的含义了。</p>
<p>（当然，Date 类在目前的 Java 版本中，只保留了一个无参和一个有参的构造函数，其他的都已经标记为 @Deprecated 了）</p>
<p>而如果使用静态工厂方法，就可以给方法起更多有意义的名字，比如前面的 valueOf、newInstance、getInstance 等，对于代码的编写和阅读都能够更清晰。</p>
<p>2.2 第二个优势，不用每次被调用时都创建新对象<br>这个很容易理解了，有时候外部调用者只需要拿到一个实例，而不关心是否是新的实例；又或者我们想对外提供一个单例时 —— 如果使用工厂方法，就可以很容易的在内部控制，防止创建不必要的对象，减少开销。</p>
<p>在实际的场景中，单例的写法也大都是用静态工厂方法来实现的。</p>
<p>如果你想对单例有更多了解，可以看一下这里：☞《Hi，我们再来聊一聊Java的单例吧》</p>
<p>2.3 第三个优势，可以返回原返回类型的子类<br>这条不用多说，设计模式中的基本的原则之一——『里氏替换』原则，就是说子类应该能替换父类。<br>显然，构造方法只能返回确切的自身类型，而静态工厂方法则能够更加灵活，可以根据需要方便地返回任何它的子类型的实例。</p>
<p>Class Person {<br>    public static Person getInstance(){<br>        return new Person();<br>        // 这里可以改为 return new Player() / Cooker()<br>    }<br>}<br>Class Player extends Person{<br>}<br>Class Cooker extends Person{<br>}<br>比如上面这段代码，Person 类的静态工厂方法可以返回 Person 的实例，也可以根据需要返回它的子类 Player 或者 Cooker。（当然，这只是为了演示，在实际的项目中，一个类是不应该依赖于它的子类的。但如果这里的 getInstance () 方法位于其他的类中，就更具有的实际操作意义了）</p>
<p>2.4 第四个优势，在创建带泛型的实例时，能使代码变得简洁<br>这条主要是针对带泛型类的繁琐声明而说的，需要重复书写两次泛型参数：</p>
<p>Map&lt;String,Date&gt; map = new HashMap&lt;String,Date&gt;();<br>不过自从 java7 开始，这种方式已经被优化过了 —— 对于一个已知类型的变量进行赋值时，由于泛型参数是可以被推导出，所以可以在创建实例时省略掉泛型参数。</p>
<p>Map&lt;String,Date&gt; map = new HashMap&lt;&gt;();<br>所以这个问题实际上已经不存在了。</p>
<ol start="3">
<li>除此之外<br>以上是《Effective Java》中总结的几条应该使用静态工厂方法代替构造器的原因，如果你看过之后仍然犹豫不决，那么我觉得可以再给你更多一些理由 —— 我个人在项目中是大量使用静态工厂方法的，从我的实际经验来世，除了上面总结的几条之外，静态工厂方法实际上还有更多的优势。</li>
</ol>
<p>3.1 可以有多个参数相同但名称不同的工厂方法<br>构造函数虽然也可以有多个，但是由于函数名已经被固定，所以就要求参数必须有差异时（类型、数量或者顺序）才能够重载了。<br>举例来说：</p>
<p>class Child{<br>    int age = 10;<br>    int weight = 30;<br>    public Child(int age, int weight) {<br>        this.age = age;<br>        this.weight = weight;<br>    }<br>    public Child(int age) {<br>        this.age = age;<br>    }<br>}<br>Child 类有 age 和 weight 两个属性，如代码所示，它已经有了两个构造函数：Child(int age, int weight) 和 Child(int age)，这时候如果我们想再添加一个指定 wegiht 但不关心 age 的构造函数，一般是这样：</p>
<p>public Child( int weight) {<br>    this.weight = weight;<br>}<br>↑ 但要把这个构造函数添加到 Child 类中，我们都知道是行不通的，因为 java 的函数签名是忽略参数名称的，所以 Child(int age) 跟 Child(int weight) 会冲突。</p>
<p>这时候，静态工厂方法就可以登场了。</p>
<p>class Child{<br>    int age = 10;<br>    int weight = 30;<br>    public static Child newChild(int age, int weight) {<br>        Child child = new Child();<br>        child.weight = weight;<br>        child.age = age;<br>        return child;<br>    }<br>    public static Child newChildWithWeight(int weight) {<br>        Child child = new Child();<br>        child.weight = weight;<br>        return child;<br>    }<br>    public static Child newChildWithAge(int age) {<br>        Child child = new Child();<br>        child.age = age;<br>        return child;<br>    }<br>}<br>其中的 newChildWithWeight 和 newChildWithAge，就是两个参数类型相同的的方法，但是作用不同，如此，就能够满足上面所说的类似Child(int age) 跟 Child(int weight)同时存在的需求。<br>（另外，这两个函数名字也是自描述的，相对于一成不变的构造函数更能表达自身的含义，这也是上面所说的第一条优势 —— 『它们有名字』）</p>
<p>3.2 可以减少对外暴露的属性<br>软件开发中有一条很重要的经验：对外暴露的属性越多，调用者就越容易出错。所以对于类的提供者，一般来说，应该努力减少对外暴露属性，从而降低调用者出错的机会。</p>
<p>考虑一下有如下一个 Player 类：</p>
<p>// Player : Version 1<br>class Player {<br>    public static final int TYPE_RUNNER = 1;<br>    public static final int TYPE_SWIMMER = 2;<br>    public static final int TYPE_RACER = 3;<br>    protected int type;<br>    public Player(int type) {<br>        this.type = type;<br>    }<br>}<br>Player 对外提供了一个构造方法，让使用者传入一个 type 来表示类型。那么这个类期望的调用方式就是这样的：</p>
<pre><code>Player player1 = new Player(Player.TYPE_RUNNER);
Player player2 = new Player(Player.TYPE_SWEIMMER);
</code></pre><p>但是，我们知道，提供者是无法控制调用方的行为的，实际中调用方式可能是这样的：</p>
<pre><code>Player player3 = new Player(0);
Player player4 = new Player(-1);
Player player5 = new Player(10086);
</code></pre><p>提供者期望的构造函数传入的值是事先定义好的几个常量之一，但如果不是，就很容易导致程序错误。</p>
<p>—— 要避免这种错误，使用枚举来代替常量值是常见的方法之一，当然如果不想用枚举的话，使用我们今天所说的主角静态工厂方法也是一个很好的办法。</p>
<p>插一句：<br>实际上，使用枚举也有一些缺点，比如增大了调用方的成本；如果枚举类成员增加，会导致一些需要完备覆盖所有枚举的调用场景出错等。</p>
<p>如果把以上需求用静态工厂方法来实现，代码大致是这样的：</p>
<p>// Player : Version 2<br>class Player {<br>    public static final int TYPE_RUNNER = 1;<br>    public static final int TYPE_SWIMMER = 2;<br>    public static final int TYPE_RACER = 3;<br>    int type;</p>
<pre><code>private Player(int type) {
    this.type = type;
}

public static Player newRunner() {
    return new Player(TYPE_RUNNER);
}
public static Player newSwimmer() {
    return new Player(TYPE_SWIMMER);
}
public static Player newRacer() {
    return new Player(TYPE_RACER);
}
</code></pre><p>}<br>注意其中的构造方法被声明为了 private，这样可以防止它被外部调用，于是调用方在使用 Player 实例的时候，基本上就必须通过 newRunner、newSwimmer、newRacer 这几个静态工厂方法来创建，调用方无须知道也无须指定 type 值 —— 这样就能把 type 的赋值的范围控制住，防止前面所说的异常值的情况。</p>
<p>插一句：<br>严谨一些的话，通过反射仍能够绕过静态工厂方法直接调用构造函数，甚至直接修改一个已创建的 Player 实例的 type 值，但本文暂时不讨论这种非常规情况。</p>
<p>3.3 多了一层控制，方便统一修改<br>我们在开发中一定遇到过很多次这样的场景：在写一个界面时，服务端的数据还没准备好，这时候我们经常就需要自己在客户端编写一个测试的数据，来进行界面的测试，像这样：</p>
<pre><code>// 创建一个测试数据
User tester = new User();
tester.setName(&quot;隔壁老张&quot;);
tester.setAge(16);
tester.setDescription(&quot;我住隔壁我姓张！&quot;);
// use tester
bindUI(tester);
……
</code></pre><p>要写一连串的测试代码，如果需要测试的界面有多个，那么这一连串的代码可能还会被复制多次到项目的多个位置。</p>
<p>这种写法的缺点呢，首先是代码臃肿、混乱；其次是万一上线的时候漏掉了某一处，忘记修改，那就可以说是灾难了……</p>
<p>但是如果你像我一样，习惯了用静态工厂方法代替构造器的话，则会很自然地这么写，先在 User 中定义一个 newTestInstance 方法：</p>
<p>static class User{<br>    String name ;<br>    int age ;<br>    String description;<br>    public static User newTestInstance() {<br>        User tester = new User();<br>        tester.setName(“隔壁老张”);<br>        tester.setAge(16);<br>        tester.setDescription(“我住隔壁我姓张！”);<br>        return tester;<br>    }<br>}<br>然后调用的地方就可以这样写了：</p>
<pre><code>// 创建一个测试数据
User tester = User.newTestInstance();
// use tester
bindUI(tester);
</code></pre><p>是不是瞬间就觉得优雅了很多？！</p>
<p>而且不只是代码简洁优雅，由于所有测试实例的创建都是在这一个地方，所以在需要正式数据的时候，也只需把这个方法随意删除或者修改一下，所有调用者都会编译不通过，彻底杜绝了由于疏忽导致线上还有测试代码的情况。</p>
<ol start="4">
<li>总结<br>总体来说，我觉得『考虑使用静态工厂方法代替构造器』这点，除了有名字、可以用子类等这些语法层面上的优势之外，更多的是在工程学上的意义，我觉得它实质上的最主要作用是：能够增大类的提供者对自己所提供的类的控制力。</li>
</ol>
<p>作为一个开发者，当我们作为调用方，使用别人提供的类时，如果要使用 new 关键字来为其创建一个类实例，如果对类不是特别熟悉，那么一定是要特别慎重的 —— new 实在是太好用了，以致于它经常被滥用，随时随地的 new 是有很大风险的，除了可能导致性能、内存方面的问题外，也经常会使得代码结构变得混乱。</p>
<p>而当我们在作为类的提供方时，无法控制调用者的具体行为，但是我们可以尝试使用一些方法来增大自己对类的控制力，减少调用方犯错误的机会，这也是对代码更负责的具体体现。</p>
<ol start="5">
<li>最后<br>—— 感谢你花费了不少时间看到这里，但愿文章内容没让你感到虚度。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/29/Java-的静态工厂方法/" data-id="cjlv1o7i90002gc7iaj08szpb" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-java中length-length-size-区别" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/29/java中length-length-size-区别/" class="article-date">
  <time datetime="2018-08-28T17:03:39.000Z" itemprop="datePublished">2018-08-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/29/java中length-length-size-区别/">java中length,length(),size()区别</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1 java中的length属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了length这个属性.<br>2 java中的length()方法是针对字符串String说的,如果想看这个字符串的长度则用到length()这个方法.<br>3.java中的size()方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/29/java中length-length-size-区别/" data-id="cjlv1o7ih0007gc7iuyswe4k0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-为什么数组没有实现Iterable接口，但可以使用foreach语句遍历" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/27/为什么数组没有实现Iterable接口，但可以使用foreach语句遍历/" class="article-date">
  <time datetime="2018-08-27T14:29:53.000Z" itemprop="datePublished">2018-08-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/27/为什么数组没有实现Iterable接口，但可以使用foreach语句遍历/">为什么数组没有实现Iterable接口，但可以使用foreach语句遍历</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在Java中，对于数组为什么能够使用foreach语句一直感觉很困惑。</p>
<p>对于能够使用foreach语句进行遍历的对象，只有两种情况，其中一种是遍历对象必须实现Iterable接口，实现ierator()方法，这是对象使用foreach语句的前提。另外一种情况就是特殊对象数组。那么对于数组可以使用foreach该如何去理解呢？</p>
<p>首先需要说明的是，实现了java.lang.Iterable接口的对象可以用for-each去遍历，但是能用for-each去遍历的不一定实现了该接口，比如数组这个特殊对象就是这一特殊情况。但是网上关于这方面的资料很少，自己只能说下自己的理解。</p>
<p>我认为数组对象之所以能够使用foreach语句进行遍历元素，是因为JVM在底层将对于数组的foreach循环转换为对于这个数组每一个的循环引用。类似在底层转化成了普通的for语句一样，得以保证我们使用foreach语句时候能够正确的进行遍历。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/27/为什么数组没有实现Iterable接口，但可以使用foreach语句遍历/" data-id="cjlv1o7if0006gc7iu5my7nmk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-111" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/16/111/" class="article-date">
  <time datetime="2018-08-16T15:15:34.000Z" itemprop="datePublished">2018-08-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/16/111/">a=a++问题引发的思考</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>使用javap命令解析出来的a=a++过程的字节码（int a=1; a=a++）：</p>
<p>0: iconst_1  将数值1压入栈顶<br>1: istore_1  栈顶值1存入局部变量表的第一个slot中<br>2: iload_1   将第1个slot所存的变量放入栈顶<br>3: iinc 1, 1  将第1个slot所存的变量自加1<br>6: istore_1 将栈顶数据抛出，写入局部变量表的第1个slot中</p>
<p>看到此处，应该恍然大悟，问题就出在iinc这条指令上，它操作的是将局部变量表中的值加一，而非是操作数栈中的变量值加一。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/16/111/" data-id="cjlv1o7i70001gc7ib7q894pt" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/16/hello-world/" class="article-date">
  <time datetime="2018-08-16T13:24:56.434Z" itemprop="datePublished">2018-08-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/16/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/16/hello-world/" data-id="cjlv1o7id0004gc7ifxkficcx" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/09/09/Java核心技术-继承/">Java核心技术-继承</a>
          </li>
        
          <li>
            <a href="/2018/09/05/Java核心技术-对象与类/">Java核心技术-对象与类</a>
          </li>
        
          <li>
            <a href="/2018/09/03/Java核心技术-Java的基本程序设计结构/">Java核心技术-Java的基本程序设计结构</a>
          </li>
        
          <li>
            <a href="/2018/09/01/第2章—Java内存区域与内存溢出异常/">第2章—Java内存区域与内存溢出异常</a>
          </li>
        
          <li>
            <a href="/2018/08/29/Java-的静态工厂方法/">Java 的静态工厂方法</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 dyj<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>